<!DOCTYPE html>
<html>
<head>
  <title>Offscreen PDF Processor</title>
  <meta charset="utf-8">
  <!-- Load PDF.js locally instead of from CDN to comply with CSP -->
  <script src="pdfjs/pdf.min.js"></script>
  <script>
    // Simple global variable to track initialization
    let isInitialized = false;
    let pdfWorkerLoaded = false;
    let backgroundActive = true;
    
    // Make sure we log that PDF.js is actually loaded
    console.log("[OFFSCREEN] Document loaded, PDF.js available:", typeof pdfjsLib !== 'undefined');
    
    // Immediately notify the background script that we're ready
    try {
      console.log("[OFFSCREEN] Sending immediate READY signal");
      chrome.runtime.sendMessage({
        type: "OFFSCREEN_DOCUMENT_READY",
        timestamp: Date.now(),
        status: "initializing",
        isReady: true
      });
      
      // Always send a second ready signal after a short delay
      setTimeout(() => {
        chrome.runtime.sendMessage({
          type: "OFFSCREEN_DOCUMENT_READY",
          timestamp: Date.now(),
          status: "ready",
          isReady: true
        });
        console.log("[OFFSCREEN] Sent delayed READY signal");
      }, 500);
    } catch (e) {
      console.error("[OFFSCREEN] Error sending initial ready signal:", e);
    }
    
    // Initialize PDF.js worker
    function initPdfWorker() {
      try {
        console.log("[OFFSCREEN] Initializing PDF.js worker");
        
        // Make sure PDF.js is available
        if (typeof pdfjsLib !== 'undefined') {
          // Set worker source to local file
          pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdfjs/pdf.worker.min.js';
          
          console.log("[OFFSCREEN] PDF.js worker initialized successfully, worker path set");
          pdfWorkerLoaded = true;
          
          // Notify background script that worker is ready
          chrome.runtime.sendMessage({
            type: "OFFSCREEN_DOCUMENT_READY",
            timestamp: Date.now(),
            status: "worker_loaded",
            pdfWorkerLoaded: true,
            isReady: true
          });
          
          return true;
        } else {
          // If PDF.js not available, try to reload it
          console.error("[OFFSCREEN] PDF.js library not found, reloading");
          
          // Inject the PDF.js script
          const pdfScript = document.createElement('script');
          pdfScript.src = "pdfjs/pdf.min.js";
          pdfScript.onload = () => {
            console.log("[OFFSCREEN] PDF.js loaded via injection");
            
            if (typeof pdfjsLib !== 'undefined') {
              // Now set worker path
              pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdfjs/pdf.worker.min.js';
              pdfWorkerLoaded = true;
              
              // Notify background that worker is ready
              chrome.runtime.sendMessage({
                type: "OFFSCREEN_DOCUMENT_READY",
                timestamp: Date.now(),
                status: "worker_loaded_after_injection",
                pdfWorkerLoaded: true,
                isReady: true
              });
            }
          };
          
          document.head.appendChild(pdfScript);
          return false;
        }
      } catch (e) {
        console.error("[OFFSCREEN] Error initializing PDF.js worker:", e);
        
        // Even if there's an error, still tell the background we're ready, but with an error flag
        chrome.runtime.sendMessage({
          type: "OFFSCREEN_DOCUMENT_READY",
          timestamp: Date.now(),
          status: "error",
          error: e.message,
          isReady: true
        });
        
        return false;
      }
    }
    
    // Hungarian character mapping for common encoding issues
    const hungarianCharacterMap = {
      'Ă': 'Á', 'ă': 'á',
      'Ś': 'Ő', 'ś': 'ő',
      'Ę': 'É', 'ę': 'é',
      'Î': 'Í', 'î': 'í',
      'Ţ': 'Ű', 'ţ': 'ű',
      'Ş': 'Ö', 'ş': 'ö',
      'Ł': 'Ó', 'ł': 'ó',
      'Č': 'Ő', 'č': 'ő',
      'Ň': 'Ű', 'ň': 'ű',
      'ˇ': '',  // remove caron
      'ľ': 'l',
      'Ä': 'Á', 'ä': 'á',
      'Ë': 'É', 'ë': 'é',
      'Ď': 'Ö', 'ď': 'ö',
      'Ĺ': 'Ó', 'ĺ': 'ó',
      'Ü': 'Ű', 'ü': 'ű',
      'Ő': 'Ő', 'ő': 'ő', // keep these correct ones
      'Ű': 'Ű', 'ű': 'ű',
      'Á': 'Á', 'á': 'á',
      'É': 'É', 'é': 'é',
      'Í': 'Í', 'í': 'í',
      'Ó': 'Ó', 'ó': 'ó',
      'Ö': 'Ö', 'ö': 'ö',
      'Ú': 'Ú', 'ú': 'ú',
      'Ů': 'Ű', 'ů': 'ű',
      // Special handling for combined diacritics
      'a´': 'á', 'A´': 'Á',
      'e´': 'é', 'E´': 'É',
      'i´': 'í', 'I´': 'Í',
      'o´': 'ó', 'O´': 'Ó',
      'o¨': 'ö', 'O¨': 'Ö',
      'u´': 'ú', 'U´': 'Ú',
      'u¨': 'ü', 'U¨': 'Ü',
      'u˝': 'ű', 'U˝': 'Ű',
      'o˝': 'ő', 'O˝': 'Ő'
    };
    
    // Fix Hungarian encoding issues
    function fixHungarianEncoding(text) {
      console.log("[OFFSCREEN] Fixing Hungarian encoding issues");
      
      // First attempt: direct character replacement
      let fixedText = text;
      
      // Replace most common patterns first
      Object.entries(hungarianCharacterMap).forEach(([incorrect, correct]) => {
        fixedText = fixedText.replace(new RegExp(incorrect, 'g'), correct);
      });
      
      // Second attempt: try to detect and fix UTF-8/Latin-2 encoding issues
      try {
        // This helps with some specific encoding issues
        const textDecoder = new TextDecoder('iso-8859-2');
        const textEncoder = new TextEncoder();
        const bytes = textEncoder.encode(fixedText);
        const decodedText = textDecoder.decode(bytes);
        
        if (decodedText !== fixedText && decodedText.length > 0) {
          console.log("[OFFSCREEN] Applied ISO-8859-2 decoding fix");
          fixedText = decodedText;
        }
      } catch (e) {
        console.warn("[OFFSCREEN] Error applying secondary encoding fix:", e);
      }
      
      // Third attempt: apply fixes for specific patterns that might remain
      try {
        // Fix double-encoded characters (happens with some PDFs)
        fixedText = fixedText.replace(/Ă&#8218;/g, 'á')
                            .replace(/Ă&#8364;/g, 'é')
                            .replace(/Ă&#8240;/g, 'ó')
                            .replace(/Ĺ&#8364;/g, 'é')
                            .replace(/Ă&#732;/g, 'ő')
                            .replace(/ƒ&#8218;/g, 'á')
                            .replace(/ƒ&#8364;/g, 'é');
        
        // Remove common garbage sequences found in corrupted PDFs
        fixedText = fixedText.replace(/Ť&#321;&#205;&#336;/g, '')
                            .replace(/ŤŃÍŐçrç|YQ/g, '')
                            .replace(/startxref \d+ %EOF/g, '')
                            .replace(/<\/Type \/Sig \/Filter \/Adobe\.PPKLite/g, '');
                            
        // Remove binary/hexadecimal data often found in corrupted PDFs
        fixedText = fixedText.replace(/[0-9a-f]{32,}/gi, '')
                            .replace(/\bobj\s+<<.*?>>\s+endobj\b/gs, '')
                            .replace(/0x[0-9a-f]+/gi, '');
      } catch (e) {
        console.warn("[OFFSCREEN] Error applying pattern-specific fixes:", e);
      }
      
      return fixedText;
    }
    
    // Simple function to process PDF data
    async function processPdf(data, options) {
      // Make sure PDF.js is initialized
      if (!pdfWorkerLoaded) {
        const workerInitialized = initPdfWorker();
        if (!workerInitialized) {
          throw new Error("PDF.js worker could not be initialized");
        }
      }
      
      console.log("[OFFSCREEN] Processing PDF, size:", data.length, "options:", options);
      try {
        const pdfData = new Uint8Array(data);
        
        // Check if this appears to be a certificate/signature PDF
        const isLikelyCertificatePdf = detectCertificateData(pdfData);
        if (isLikelyCertificatePdf) {
          console.log("[OFFSCREEN] Detected certificate/signature PDF - using special handling");
        }
        
        // Create document loading task with special options for Hungarian PDFs
        const loadingTask = pdfjsLib.getDocument({
          data: pdfData,
          disableFontFace: true,
          disableRange: true,
          // Additional parameters for better Hungarian encoding
          ...(options?.language === 'hu' ? {
            useWorker: false, // Disable worker for more control
            isEvalSupported: false, // Avoid eval which can cause encoding issues
            nativeImageDecoderSupport: 'none', // Skip images to focus on text
            verbosity: 1 // More logging
          } : {})
        });
        
        // Load document
        const pdfDoc = await loadingTask.promise;
        console.log("[OFFSCREEN] Loaded PDF with", pdfDoc.numPages, "pages");
        
        // Extract text from all pages
        let fullText = "";
        const pages = [];
        
        // Respect max pages setting or process all pages
        const maxPages = options?.maxPages || pdfDoc.numPages;
        const pagesToProcess = Math.min(maxPages, pdfDoc.numPages);
        
        for (let i = 1; i <= pagesToProcess; i++) {
          const page = await pdfDoc.getPage(i);
          
          // Use different extraction approaches depending on language
          let pageText = "";
          
          if (options?.language === 'hu') {
            // For Hungarian documents, we'll try a more careful approach
            try {
              // First try with standard text extraction
              const content = await page.getTextContent({
                normalizeWhitespace: true,
                disableCombineTextItems: false
              });
              
              // Extract text with proper spacing
              let lastY;
              let lastX;
              
              for (const item of content.items) {
                if (lastY !== item.transform[5] && pageText) {
                  pageText += "\n";
                } else if (lastX !== undefined && item.transform[4] - lastX > 10) {
                  pageText += " ";
                }
                
                pageText += item.str || "";
                lastY = item.transform[5];
                lastX = item.transform[4] + item.width;
              }
              
              // Check if text appears to be certificate data
              if (isCertificateOrBinaryData(pageText)) {
                console.log("[OFFSCREEN] Page", i, "appears to contain certificate/binary data, trying alternative extraction");
                
                // Try alternative approach: simple string extraction with line breaks
                try {
                  const simpleItems = content.items.map(item => item.str || "");
                  if (simpleItems.length > 0) {
                    const simpleText = simpleItems.join(" ");
                    
                    // If simple extraction produced readable text, use it
                    if (simpleText.length > 100 && !isCertificateOrBinaryData(simpleText)) {
                      pageText = simpleText;
                    }
                  }
                } catch (simpleError) {
                  console.warn("[OFFSCREEN] Simple extraction failed:", simpleError);
                }
              }
            } catch (textError) {
              console.warn("[OFFSCREEN] Standard text extraction failed:", textError);
            }
          } else {
            // Standard extraction for non-Hungarian documents
            const content = await page.getTextContent({
              normalizeWhitespace: true,
              disableCombineTextItems: false
            });
            
            // Extract text with proper spacing
            let lastY;
            let lastX;
            
            for (const item of content.items) {
              if (lastY !== item.transform[5] && pageText) {
                pageText += "\n";
              } else if (lastX !== undefined && item.transform[4] - lastX > 10) {
                pageText += " ";
              }
              
              pageText += item.str || "";
              lastY = item.transform[5];
              lastX = item.transform[4] + item.width;
            }
          }
          
          // Apply language-specific fixes
          if (options?.language === 'hu') {
            pageText = fixHungarianEncoding(pageText);
          }
          
          // Remove certificate/binary data if detected
          if (isCertificateOrBinaryData(pageText)) {
            console.log("[OFFSCREEN] Removing certificate/binary data from page", i);
            pageText = cleanupCertificateData(pageText);
          }
          
          fullText += pageText + "\n\n";
          
          // Add to pages array
          pages.push({
            pageNumber: i,
            text: pageText
          });
          
          page.cleanup();
        }
        
        // Final encoding fix on the full text if Hungarian
        if (options?.language === 'hu') {
          fullText = fixHungarianEncoding(fullText);
        }
        
        // Final cleanup of certificate/binary data
        fullText = cleanupCertificateData(fullText);
        
        console.log("[OFFSCREEN] Extracted text from", pagesToProcess, "pages");
        
        // Return the result
        return {
          success: true,
          text: fullText.trim(),
          pages,
          pagesProcessed: pagesToProcess
        };
      } catch (error) {
        console.error("[OFFSCREEN] Error processing PDF:", error);
        return {
          success: false,
          text: "",
          error: error.message || "Unknown error",
          pages: []
        };
      }
    }
    
    /**
     * Check if the text appears to be certificate/binary data
     */
    function isCertificateOrBinaryData(text) {
      if (!text) return false;
      
      // Check for common patterns in certificate data
      const certificatePatterns = [
        /\/Type\s+\/Sig/i,
        /\/Filter\s+\/Adobe\.PPKLite/i,
        /\/SubFilter\s+\/ETSI\.CAdES/i,
        /startxref\s+\d+\s+%EOF/i,
        /obj\s*<<.*?>>\s*endobj/i,
        /[0-9a-f]{30,}/i, // Long hex sequences
        /^\d+\s+\d+\s+obj/m // PDF object definition
      ];
      
      // Check if the text contains certificate patterns
      for (const pattern of certificatePatterns) {
        if (pattern.test(text)) {
          return true;
        }
      }
      
      // Check for high ratio of non-readable characters
      const nonReadableCount = (text.match(/[^\w\s,.?!;:()\-]/g) || []).length;
      const totalLength = text.length;
      
      if (totalLength > 0 && (nonReadableCount / totalLength) > 0.3) {
        return true;
      }
      
      return false;
    }
    
    /**
     * Clean up certificate or binary data from text
     */
    function cleanupCertificateData(text) {
      if (!text) return "";
      
      // Remove common certificate sections
      return text
        .replace(/\/Type\s+\/Sig.*?endobj/gs, '')
        .replace(/startxref\s+\d+\s+%EOF.*/gs, '')
        .replace(/\d+\s+\d+\s+obj\s*<<.*?>>\s*endobj/gs, '')
        .replace(/[0-9a-f]{30,}/gi, '')
        .replace(/\/Filter\s+\/Adobe\.PPKLite.*/gs, '');
    }
    
    /**
     * Detect if the PDF data appears to be a certificate
     */
    function detectCertificateData(pdfData) {
      // Quick check: look for patterns in the first 1000 bytes
      const sampleData = pdfData.slice(0, Math.min(1000, pdfData.length));
      const sampleText = new TextDecoder().decode(sampleData);
      
      // Check for certificate patterns in the sample
      return sampleText.includes('/Type /Sig') || 
             sampleText.includes('Adobe.PPKLite') ||
             sampleText.includes('ETSI.CAdES');
    }
    
    // Keep-alive ping interval to ensure service worker stays active
    const pingInterval = setInterval(() => {
      chrome.runtime.sendMessage({
        type: "PING_OFFSCREEN_DOCUMENT",
        timestamp: Date.now()
      }, (response) => {
        if (chrome.runtime.lastError) {
          console.warn("[OFFSCREEN] Background script not responding:", chrome.runtime.lastError.message);
          backgroundActive = false;
        } else {
          console.log("[OFFSCREEN] Background is active, received response:", response?.type);
          backgroundActive = true;
        }
      });
    }, 25000); // Ping every 25 seconds
    
    // Set up message listeners
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      console.log("[OFFSCREEN] Received message:", message?.type);
      
      // Handle ping messages
      if (message?.type === "PING_OFFSCREEN_DOCUMENT") {
        console.log("[OFFSCREEN] Received ping, sending pong");
        try {
          sendResponse({ type: "PONG_OFFSCREEN_DOCUMENT" });
          
          // Also send a ready signal
          chrome.runtime.sendMessage({
            type: "OFFSCREEN_DOCUMENT_READY",
            timestamp: Date.now(),
            isReady: true
          });
        } catch (e) {
          console.error("[OFFSCREEN] Error responding to ping:", e);
        }
        return true;
      }
      
      // Handle PDF processing
      if (message?.type === "PROCESS_PDF") {
        console.log("[OFFSCREEN] Starting PDF processing");
        
        // Process the PDF
        processPdf(message.pdfData, message.options)
          .then(result => {
            console.log("[OFFSCREEN] PDF processing complete, sending result");
            
            // Make sure background is active before sending result
            ensureBackgroundActive().then(() => {
              sendMessageWithRetry({
                type: "PDF_PROCESSED",
                result,
                messageId: message.messageId
              });
            });
          })
          .catch(error => {
            console.error("[OFFSCREEN] Error in PDF processing:", error);
            
            // Make sure background is active before sending error
            ensureBackgroundActive().then(() => {
              sendMessageWithRetry({
                type: "PDF_PROCESSING_ERROR",
                error: error.message || "Unknown error",
                messageId: message.messageId
              });
            });
          });
        
        return true;
      }
    });
    
    /**
     * Send a message with retry capability
     */
    function sendMessageWithRetry(message, maxRetries = 3) {
      let retries = 0;
      
      function attemptSend() {
        chrome.runtime.sendMessage(message, (response) => {
          if (chrome.runtime.lastError) {
            console.warn(`[OFFSCREEN] Error sending message (attempt ${retries + 1}):`, chrome.runtime.lastError.message);
            
            if (retries < maxRetries) {
              retries++;
              console.log(`[OFFSCREEN] Retrying in ${retries * 500}ms...`);
              setTimeout(attemptSend, retries * 500);
            } else {
              console.error("[OFFSCREEN] Failed to send message after", maxRetries, "attempts:", message.type);
            }
          } else {
            console.log("[OFFSCREEN] Message sent successfully:", message.type);
          }
        });
      }
      
      attemptSend();
    }
    
    /**
     * Ensure background is active before sending important messages
     */
    async function ensureBackgroundActive() {
      if (backgroundActive) return true;
      
      // Try to ping the background script
      return new Promise((resolve) => {
        console.log("[OFFSCREEN] Ensuring background is active before sending message");
        
        // Try up to 3 times with increasing delays
        let attempts = 0;
        const maxAttempts = 3;
        
        function attemptPing() {
          chrome.runtime.sendMessage({
            type: "PING_OFFSCREEN_DOCUMENT",
            timestamp: Date.now()
          }, (response) => {
            if (chrome.runtime.lastError) {
              console.warn(`[OFFSCREEN] Background not responding (attempt ${attempts + 1}):`, chrome.runtime.lastError.message);
              
              if (attempts < maxAttempts) {
                attempts++;
                const delay = attempts * 300;
                console.log(`[OFFSCREEN] Retrying in ${delay}ms...`);
                setTimeout(attemptPing, delay);
              } else {
                console.warn("[OFFSCREEN] Background may not be active, proceeding anyway");
                backgroundActive = false;
                resolve(false);
              }
            } else {
              console.log("[OFFSCREEN] Background is active, can send message");
              backgroundActive = true;
              resolve(true);
            }
          });
        }
        
        attemptPing();
      });
    }
    
    // Initialize PDF library after a short delay to ensure document is fully loaded
    setTimeout(() => {
      initPdfWorker();
    }, 100);
    
    // Mark as initialized when everything is done
    isInitialized = true;
    console.log("[OFFSCREEN] Document fully initialized and ready");
    
    // Additional heartbeat to help in debugging
    setInterval(() => {
      console.log("[OFFSCREEN] Heartbeat - Document is active");
    }, 10000);
  </script>
</head>
<body>
  <div id="status">Offscreen PDF Processor is running</div>
</body>
</html> 