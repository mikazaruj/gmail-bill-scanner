<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>PDF Processing</title>
</head>
<body>
  <div id="pdf-container" style="display: none;"></div>
  <script>
    console.log('Offscreen PDF processing document initialized');
    
    // Import the clean PDF processor
    importScripts('lib/pdf.js', 'lib/pdf.worker.js');
    
    // Listen for messages from the service worker
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      console.log('Offscreen document received message:', message.type);
      
      if (message.type === 'PROCESS_PDF') {
        processPdf(message.pdfData, message.options)
          .then(result => sendResponse(result))
          .catch(error => {
            console.error('Error processing PDF:', error);
            sendResponse({
              success: false,
              error: error.message || 'Failed to process PDF'
            });
          });
          
        return true; // Keep the message channel open for async response
      }
      
      // Send a simple response for any other messages
      sendResponse({ success: false, error: 'Unsupported operation' });
      return false;
    });
    
    // Process PDF data using PDF.js
    async function processPdf(pdfData, options = {}) {
      try {
        // Convert data if needed
        const typedArray = pdfData instanceof Uint8Array ? 
          pdfData : new Uint8Array(pdfData);
        
        // Load the PDF document
        const loadingTask = pdfjsLib.getDocument({
          data: typedArray,
          cMapUrl: 'https://unpkg.com/pdfjs-dist@2.16.105/cmaps/',
          cMapPacked: true,
        });
        
        // Set a timeout to prevent hanging
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => {
            loadingTask.destroy();
            reject(new Error('PDF processing timed out'));
          }, options.timeout || 30000);
        });
        
        // Load the document with timeout
        const pdfDocument = await Promise.race([
          loadingTask.promise,
          timeoutPromise
        ]);
        
        const numPages = pdfDocument.numPages;
        const pages = [];
        let fullText = '';
        
        // Extract text from each page
        for (let i = 1; i <= numPages; i++) {
          const page = await pdfDocument.getPage(i);
          const textContent = await page.getTextContent();
          
          let pageText = '';
          for (const item of textContent.items) {
            if ('str' in item) {
              pageText += item.str + ' ';
            }
          }
          
          fullText += pageText + '\n';
          pages.push({
            pageNumber: i,
            text: pageText
          });
          
          // Clean up page resources
          page.cleanup();
        }
        
        // Close the PDF document
        pdfDocument.destroy();
        
        return {
          success: true,
          text: fullText,
          pages: pages
        };
      } catch (error) {
        console.error('Error processing PDF in offscreen document:', error);
        return {
          success: false,
          error: error.message || 'Unknown PDF processing error'
        };
      }
    }
    
    // Notify the service worker that the offscreen document is ready
    chrome.runtime.sendMessage({
      type: 'OFFSCREEN_PDF_READY'
    });
  </script>
</body>
</html> 